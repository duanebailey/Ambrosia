#!/usr/bin/env python3
# Project Ambrosia (c) 2013-19 duane a. bailey
"""Basic camera definitions.

(c) 2013 duane a. bailey

This module defines the classes that support camera-like objects.

Classes defined here:
  Image             - rendering of camera view
  Camera
    StereoCamera    - red-bluegreen stereo camera
    PIPCamera       - picture-in-picture camera
    IsometricCamera - architectural view
"""
import abc
import os
import math
from collections import Iterable
from ambrosia.decorators import *
from ambrosia.basics import *
from ambrosia.objects import *

__all__ = ('Camera', 'Image', 'IsometricCamera', 'PIPCamera', 'StereoCamera')


###############################################################################
# Image: a camera rendering
@checkdoc
class Image(AmbrosiaObject):
    """This class represents a rendering of what a camera sees.

    Images are the external representation of the view of a virtual scene
    from a camera.  Images can be manipulated directly, but they are typically
    generated by and associated with a camera.

    The most commonly used methods are used to control the size and aspect
    ratio of the image.   By default, images are 640pixels (wide) and 
    480pixels (tall), leading to an aspect ratio of 4::3, or 1.333.  By
    changing the width or height of an image, the image's size is scaled
    in a way to preserve the aspect ratio.  For example,
        i.width(320)
    would reduce the image's width from 640 to 320.  Ambrosia will maintain
    the current aspect ratio, unless told otherwise.  Thus the height of 
    the image will also change -- from 480 to 240.  It's also possible
    to change the height in the analagous way.

    To set both dimensions of the image at the same time, use dimensions:
        i.dimensions(300,150)
    sets the width to 300 and the height to 150.  The aspect ratio then
    changes to 2.

    To set the aspect ratio, use aspectRatio:
        i.aspectRatio(0.75)
    This causes the desired aspect ratio to change by modifying height.

    The antiAlias methods change the smoothing of images to reduce "jaggies"
    associated with pixelation.

    viewResult, keep, and debug are switches that control the information
    presented (or kept) when images are shot.  If viewResult is True, the
    image is displayed once rendered.  If keep is True, intermediate files 
    generated are not deleted; when debug is True, settings are dumped
    to the screen when the image is rendered.

    The fog attributes control the image post-processing in POV necessary
    to simulate fog.

    The file name associated with an Image is set with the fileName methods.
    In cases where a single image is used to generate the frames of a movie,
    the frameNumber methods indicate the order of the images.
    """
    def __init__(self,description="An image."):
        super().__init__(description=description)
        self.set('image.aspectRatio',640/480)
        self.dimensions(640,480).quality(8).antiAlias(0.5)
        self.viewResult(True).keep(False).debug(False)
        self.background([1,1,1])
        self.fogColor([1,1,1]).fogAttenuation(100)

    def getViewResult(self):
        """Get value of viewResult."""
        return self.get('image.viewResult')

    def viewResult(self,v):
        """Set value of viewResult."""
        self.set('image.viewResult',v)
        return self

    def getKeep(self):
        """Get value of keep."""
        return self.get('image.keep')

    def keep(self,v):
        """Set value of keep to v."""
        self.set('image.keep',v)
        return self

    def getDebug(self):
        """Get value of debug."""
        return self.get('image.debug')

    def debug(self,v):
        """Set value of debug to v."""
        self.set('image.debug',v)
        return self

    def getAspectRatio(self):
        """Get value of aspectRatio."""
        return self.get('image.aspectRatio')

    def aspectRatio(self,v):
        """Set value of aspectRatio to v (may change height)."""
        self.set('image.aspectRatio',v)
        if self.getWidth() > 0:
            self.height(self.getWidth()/v)
        return self

    def setAspectRatio(self,v):
        """Set value of aspectRatio to v (may change height)."""
        self.set('image.aspectRatio',v)
        return self

    def getWidth(self):
        """Get value of width."""
        return self.get('image.width')

    def width(self,v):
        """Set value of width to v."""
        self.set('image.width',v)
        self.set('image.height',v/self.getAspectRatio())
        return self

    def getHeight(self):
        """Get value of height."""
        return self.get('image.height')

    def height(self,v):
        """Set value of height to v."""
        self.width(self.getAspectRatio()*v)
        return self

    def getDimensions(self):
        """Get value of dimensions."""
        return (self.getWidth(),self.getHeight())

    def dimensions(self,w,h):
        """Set value of dimensions to v."""
        self.set('image.width',w)
        self.set('image.height',h)
        self.set('image.aspectRatio',w/h)
        return self

    def getQuality(self):
        """Get value of quality."""
        return self.get('image.quality')

    def quality(self,v):
        """Set value of quality to v."""
        self.set('image.quality',v)
        return self

    def getAntiAlias(self):
        """Get value of antiAlias."""
        return self.get('image.antiAlias')

    def antiAlias(self,v):
        """Set value of antiAlias to v."""
        self.set('image.antiAlias',v)
        return self

    def getBackground(self):
        """Get value of background."""
        return self.get('image.background')

    def background(self,v):
        """Set value of background to v."""
        self.set('image.background',v)
        return self

    def getFog(self):
        """Get value of fog."""
        return self.get('image.fog')

    def fog(self):
        """Set fog."""
        self.set('image.fog',1)
        return self

    def groundFog(self):
        """Set ground fog."""
        self.set('image.fog',2)
        return self

    def getFogColor(self):
        """Get value of fogColor."""
        return self.get('image.fogColor')

    def fogColor(self,v):
        """Set value of fogColor to v."""
        self.set('image.fogColor',v)
        return self

    def getFogAttenuation(self):
        """Get value of fogAttenuation."""
        return self.get('image.fogAttenuation')

    def fogAttenuation(self,v):
        """Set value of fogAttenuation to v."""
        self.set('image.fogAttenuation',v)
        return self

    def getFrameNumber(self):
        """Get value of frameNumber."""
        return self.get('image.frameNumber')

    def frameNumber(self,v):
        """Set value of frameNumber to v."""
        self.set('image.frameNumber',v)
        return self

    def getFileName(self):
        """Get value of fileName."""
        return self.get('image.fileName')

    def fileName(self,v):
        """Set value of fileName to v."""
        self.set('image.fileName',v)
        return self

    def getFilePath(self):
        """Get value of filePath."""
        if self.getFileName() is None:
            return None
        else:
            # the path of the file associated with the camera is
            # determined by the current file name (which defaults to user),
            # the current project folder (which defaults to /tmp),
            # and the current directory (which is found in cwd)
            here = os.getcwd() or "/home/jovyan/images"
            user = os.getenv("USER") or "untitled"
            file = self.getFileName()
            file = (isinstance(file,str) and (file != "") and file) or user
            file = [file]
            absolute = file[0][:1] == '/'
            folder = environment.getProjectFolder()
            if not (isinstance(folder,str) and folder):
                folder = '/home/jovyan/images'
            folder = [] if absolute else [ folder ]
            absolute = absolute or (folder[0][:1] == '/')
            here = [] if absolute else [os.getcwd() or "/home/jovyan/images"]
            result =  '/'.join(here+folder+file)
            return result
            
    def advanceFrame(self,delta=1):
        """Increase frame counter by delta (default: 1)."""
        if self.getFrameNumber() is not None:
            self.frameNumber(self.getFrameNumber()+delta)
        return self

    def rewindFrame(self,delta):
        """Decrease the frame number by delta (default: -1)."""
        self.advanceFrame(delta=-delta)

    def getFileNameSwitches(self):
        """Get switches associated with rendering image."""
        fp = self.getFilePath()
        n = self.getFrameNumber()
        ks = " --keep" if self.getKeep() else ""
        ds = " --debug" if self.getDebug() else ""
        vsw = "" if self.getViewResult() else " --batch"
        sw = "".join([ks,ds,vsw])
        if fp is not None:
            if n is not None:
                self.advanceFrame()
                return ' --output "{}" --frame {} {}'.format(fp,n,sw)
            else:
                return ' --output "{}" {}'.format(fp,sw)
        else:
            return ''

    def _POV_shootSuffix(self,sfx,*args):
        pov.open("/home/jovyan/images/"+os.getenv("USER")+sfx+".ini")
        self._POV_proof()
        pov.close()

    def _POV_shoot(self,*args):
        """Shoot image to POV-base image."""
        self._POV_shootSuffix("",*args)

    def _POV_proof(self,*args):
        """Proof a POV image."""
        self._POV_()

    def _POV_(self,context=None):
        environment._POV_(context)
        prt("Width={}\n".format(self.getWidth()))
        prt("Height={}\n".format(self.getHeight()))
        prt("Quality={}\n".format(self.getQuality()))
        aa = self.getAntiAlias()
        if aa != 0:
            prt("Antialias=on\nAntialias_Threshold={}\n".format(3*(1-aa)))

###############################################################################
# Camera: camera base class
@checkdoc
class Camera(AmbrosiaObject):
    """This is the base class for all camera objects.

Several parameters control the camera's view of a subject.  First, the
subject is an object that is seen by the camera.  By default, it is the
"scene" global object.  If a primitive is not part of this viewed object,
it will not be visible to the camera.  Next is the position of the camera.
This is the location of the pinhole.  The center-of-interest (or COI) is
the location that is central in all images taken by the camera.  The angle
of the camera is the angle the pinhole makes with the widest aspect of
the image; this determines whether the camera is telephoto or macro.  By 
default, the angle is 53 degrees.  The final component is the "up" direction
vector.  This is the desired direction to the top of the camera from the
pinhole.  It's important to realize that this is not necessary parallel to
the pinhole/cameratop direction vector, but is simply used to maximize the
dot-product of the two vectors.  Typically, we set the up vector to (0,1,0).

"""
    def __init__(self,description="A camera."):
        super().__init__(description=description)
        self.perspective()
        self.image(Image())
        self.COI(origin)
        self.pos([0,0,-500])
        self.up([0,1,0])
        self.angle(53)
        self.subject(None)
        self.renderer("POV")  # should this be moved?

    def type(self,t):
        """Set the camera type."""
        self.set('camera.type',t)
        return self

    def perspective(self):
        """Set camera for perspective use."""
        self.type("perspective")
        return self
    
    def orthographic(self):
        """Set camera for othographic use."""
        self.type("orthographic")
        return self
    
    def getType(self):
        """Identify camera type."""
        return self.get('camera.type')

    def pos(self,p):
        """Adjust position (absolute if p is a point, relative if transform)."""
        if isinstance(p,Transform):
            p = p.mapPoint(self.getPos())
        self.set('camera.pos',p)
        return self

    def getPos(self):
        """Return current camera position."""
        return self.get('camera.pos')

    def COI(self,p):
        """Adjust center of interest (absolute if p is a point, relative if transform)."""
        if isinstance(p,Transform):
            p = p.mapPoint(self.getCOI())
        self.set('camera.coi',p)
        return self

    def getCOI(self):
        """Return current camera center of interest."""
        return self.get('camera.coi')

    def direction(self,v):
        """Set center of interest relative to current position."""
        self.COI(vectorSum(self.getPos(),v))
        return self

    def getDirection(self):
        """Determine the camera's direction vector."""
        return vectorDifference(self.getCOI(),self.getPos())

    def up(self,v):
        """Set up direction for camera."""
        self.set('camera.up',v)
        return self

    def getUp(self):
        """Get the up vector for the camera."""
        return self.get('camera.up')

    def angle(self,a):
        """Set the camera's lens angle."""
        self.set('camera.angle',a)
        return self

    def getAngle(self):
        """Determine the camera's lens angle."""
        return self.get('camera.angle')

    def subject(self,scene):
        """Set the camera's subject."""
        self.set('camera.subject',scene)
        return self

    def getSubject(self):
        """Get the camera's actual subject."""
        return self.get('camera.subject')

    def renderer(self,engine):
        """Set the renderer to a particular type (POV, etc)."""
        self.set('camera.renderer',engine)
        return self
    
    def getRenderer(self):
        """Get the renderer engine type."""
        return self.get('camera.renderer')

    def image(self,i):
        """Set the image for the camera to render to."""
        self.set('camera.image',i)
        return self

    def getImage(self):
        """Get the image associated with this camera."""
        return self.get('camera.image')

    def shoot(self,subject=None,*args):
        """Shoot an image."""
        oldSubject = None
        if subject is not None:
            oldSubject = self.getSubject()
            self.subject(subject)
        r = self.getRenderer()
        if r == "POV":
            result = self._POV_shoot(*args)
        else:
            assert(False)
        if oldSubject is not None:
            self.subject(oldSubject)
        return result
    
    def proof(self,*args):
        """Proof an image."""
        r = self.getRenderer()
        if r == "POV":
            self._POV_proof(*args)
        else:
            assert(False)

    def _paramBuilder(self,t,params):
        return [ (blend(t,*p) if isinstance(p,Iterable) else p) for p in params]

    def film(self,n,setupFun,*params):
        """Shoot several images to successive frames."""
        for t in morph(n,0,1):
            args = self._paramBuilder(t,params)
            setupFun(*args)
            self.shoot()

    def watch(self,n,setupFun,*params):
        """Shoot several images to successive frames."""
        i = self.getImage()
        for t in morph(n,0,1):
            args = self._paramBuilder(t,params)
            setupFun(*args)
            i.advanceFrame()

    def _POV_shoot(self,*args):
        i = self.getImage()
        fnsw = i.getFileNameSwitches()
        # Dump the .ini file
        pov.open("/home/jovyan/images/{}.ini".format(os.getenv("USER")))
        i._POV_shoot(*args)
        pov.close()
        # Dump the .pov file
        pov.open("/home/jovyan/images/{}.pov".format(os.getenv("USER")))
        self._POV_proof(*args)
        pov.close()
        script = executableDir + "ambrosia-jupyter-pov"
        if not fileExists(script):
            print("Cannot find ambrosia's POV script; is ambrosia set up correctly?")
            exit(1)
        output = docmdWoutput(script+fnsw)
        resultname = [ line.split(':')[1].strip() for line in output if line.startswith('OUTFILENAME:')][0]
        from IPython.display import Image
        w = i.getWidth()
        h = i.getHeight()
        return Image (filename=resultname,width=w,height=h)

    def _POV_proof(self,*args):
        i = self.getImage()
        if i:
            b = i.getBackground()
            f = i.getFog()
            fc = i.getFogColor()
            fa = i.getFogAttenuation()/math.log(2) # not sure this is right base
            if b:
                prt("background{")
                pov.writeColor(b)
                prt("}\n")
            if f == 1:
                prt('fog {{ fog_type {} '.format(f))
                if fc:
                    pov.writeColor(fc)
                prt(' distance {} }}\n'.format(fa))
        theContext = Context()
        # selection predicate stuff removed, here
        POV(self.getSubject(),theContext)
        POV(self,theContext)

    def buildMovie(self):
        """Combine latest version of images into a movie."""
        i = self.getImage()
        pn = i.getFilePath() or os.getenv("USER") or "untitled"
        docmd(executableDir + 'ambrosia-buildMovie --project "{}" --framecount {}'.format(pn,i.getFrameNumber()))
    
    def _POV_(self,context):
        ar = self.getImage().getAspectRatio()
        up = self.getUp()
        ul = vectorLength(self.getUp())
        right = vectorScale(normalize(crossProduct(up,self.getDirection())),ul*ar)
        prt("camera {")
        prt(" {} ".format(self.getType()))
        prt(" right {}*x".format(ar))
        prt(" up y")
        prt(" sky ")
        pov.writePoint(up)
        prt(" location ")
        pov.writePoint(self.getPos())
        prt(" look_at ")
        pov.writePoint(self.getCOI())
        prt(" angle {} ".format(self.getAngle()))
        prt("}\n")

###############################################################################
# StereoCamera: a camera that shoots red-bluegreen images.
@checkdoc
class StereoCamera(Camera):
    """A camera that shoots red-bluegreen images."""
    def __init__(self,description="A stereo camera."):
        """Initialize the camera."""
        super().__init__(description=description)
        self.separation(10)

    def separation(self,s):
        """Specify the distance between cameras; must be > 0 for stereo."""
        self.set('stereocamera.separation',s)
        return self

    def getSeparation(self):
        """Return the separation of the two cameras."""
        return self.get('stereocamera.separation')

    def getLeftPos(self):
        """Return the position of the left camera."""
        s = self.getSeparation()
        u = self.getUp()
        p = self.getPos()
        d = self.getDirection()
        c = normalize(crossProduct(d,u))
        halfS = s/2
        return (p[0]+halfS*c[0],p[1]+halfS*c[1],p[2]+halfS*c[2])

    def getRightPos(self):
        """Return the position of the left camera."""
        s = self.getSeparation()
        u = self.getUp()
        p = self.getPos()
        d = self.getDirection()
        c = normalize(crossProduct(u,d))
        halfS = s/2
        return (p[0]+halfS*c[0],p[1]+halfS*c[1],p[2]+halfS*c[2])

    def _POV_shoot(self,*args):
        """Writes the output to a POV temporary file."""
        nosePos = self.getPos()
        leftPos = self.getLeftPos()
        rightPos = self.getRightPos()
        i = self.getImage()
        fnsw = i.getFileNameSwitches()
        # Dump the .ini file
        pov.open("/home/jovyan/images/{}.ini".format(os.getenv("USER")))
        i._POV_shoot(*args)
        pov.close()
        vsw = "" if i.getViewResult() else " --batch"
        i._POV_shoot(*args)
        lf = pov.open("/home/jovyan/images/{}-left.pov".format(os.getenv("USER")))
        self.pos(leftPos)
        self._POV_proof(*args)
        pov.close()
        rf = pov.open("/home/jovyan/images/{}-right.pov".format(os.getenv("USER")))
        self.pos(rightPos)
        self._POV_proof(*args)
        pov.close()
        self.pos(nosePos)
        docmd(executableDir + "ambrosia-pov --stereo"+fnsw+vsw)

###############################################################################
# PIPCamera: a picture-in-picture mode; great for animations.
#
@checkdoc
class PIPCamera(Camera):
    """Picture-in-picture cameras can help with getting two views."""
    def __init__(self,description="A picture-in-picture camera."):
        """Initialize the camera."""
        super().__init__(description=description)
        self.inset(self)
        self.insetPosition("SouthEast")

    def insetPosition(self,g):
        """Set the inset position to "South", "NorthWest", etc."""
        self.set('pipcamera.gravity',g)
        return self

    def getInsetPosition(self):
        """Get the inset position."""
        return self.get('pipcamera.gravity')

    def inset(self,other):
        """Assign another camera as inset."""
        self.set('pipcamera.insetcamera',other)
        return self

    def getInset(self):
        """Get the currently assigned inset camera."""
        return self.get('pipcamera.insetcamera')

    def _POV_shoot(self,*args):
        """Shoot a picture-in-picture image; causes other camera to shoot."""
        icam = self.getInset()
        i = self.getImage()
        ii = icam.getImage()
        fnsw = i.getFileNameSwitches()
        vsw = "" if i.getViewResult() else " --batch"
        i._POV_shootSuffix("-large",*args)
        ii._POV_shootSuffix("-small",*args)
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-large.pov")
        self._POV_proof(*args)
        pov.close()
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-small.pov")
        icam._POV_proof(*args)
        pov.close()
        docmd(executableDir + 'ambrosia-pov --pip --gravity "{}" {}{}'.format(self.getInsetPosition(),fnsw,vsw))

###############################################################################
# IsometricCamera: shoot from three orthoganal locations & perspective
@checkdoc
class IsometricCamera(Camera):
    """An isometric camera is useful for measuring features."""
    def __init__(self,description="An isometric camera."):
        """Initialize the isometric camera."""
        super().__init__(description=description)
        self.orthographic().pos([0,0,-500]).COI(origin)
    
    def getRightPos(self):
        """Get the position of the 'view-from-right' image."""
        return yRot(-90).mapPoint(self.getPos())

    def getTopPos(self):
        """Get the position of the 'view-from-top' image."""
        return xRot(90).mapPoint(self.getPos())

    def getOrthoPos(self):
        """Get the position of the 'view-from-right' image."""
        return (yRot(-30)*xRot(30)).mapPoint(self.getPos())

    def _POV_shoot(self,subject=None,*args):
        frontPos = self.getPos()
        orthoPos = self.getOrthoPos()
        rightPos = self.getRightPos()
        topPos = self.getTopPos()
        i = self.getImage()
        fnsw = i.getFileNameSwitches()
        vsw = "" if i.getViewResult() else " --batch"
        i._POV_shoot(*args)
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-ortho.pov")
        self.pos(orthoPos)
        self._POV_proof(*args)
        pov.close()
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-right.pov")
        self.pos(rightPos)
        self._POV_proof(*args)
        pov.close()
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-top.pov")
        self.pos(topPos)
        self._POV_proof(*args)
        pov.close()
        pov.open("/home/jovyan/images/"+os.getenv("USER")+"-front.pov")
        self.pos(frontPos)
        self._POV_proof(*args)
        pov.close()
        # left in correct position
        docmd(executableDir + "ambrosia-pov --isometric "+fnsw+vsw)
